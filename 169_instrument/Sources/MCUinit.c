/*
 ** ###################################################################
 **     This code is generated by the Device Initialization Tool.
 **     It is overwritten during code generation.
 **     USER MODIFICATION ARE PRESERVED ONLY INSIDE INTERRUPT SERVICE ROUTINES
 **     OR EXPLICITLY MARKED SECTIONS
 **
 **     Project   : Project_1
 **     Processor : MC9S12G128CLL
 **     Version   : Component 01.016, Driver 01.05, CPU db: 3.00.002
 **     Datasheet : MC9S12GRMV1 Rev. 0.29 April 20, 2010
 **     Date/Time : 2017/4/1, 15:38
 **     Abstract  :
 **         This module contains device initialization code
 **         for selected on-chip peripherals.
 **     Contents  :
 **         Function "MCU_init" initializes selected peripherals
 **
 **     Copyright : 1997 - 2010 Freescale Semiconductor, Inc. All Rights Reserved.
 **
 **     http      : www.freescale.com
 **     mail      : support@freescale.com
 ** ###################################################################
 */
/* MODULE MCUinit */



#include "include.h"

/* Standard ANSI C types */
#ifndef int8_t
typedef signed char int8_t;
#endif
#ifndef int16_t
typedef signed int int16_t;
#endif
#ifndef int32_t
typedef signed long int int32_t;
#endif

#ifndef uint8_t
typedef unsigned char uint8_t;
#endif
#ifndef uint16_t
typedef unsigned int uint16_t;
#endif
#ifndef uint32_t
typedef unsigned long int uint32_t;
#endif

#define CGM_DELAY  0x0BFFU

/* User declarations and definitions */
#include "config.h"
#include "global.h"

static unsigned int TimerCounter;
unsigned char rxdata[8];

/*   Code, declarations and definitions here will be preserved during code generation */
/* End of user declarations and definitions */

extern void near _Startup(void);

#pragma CODE_SEG __NEAR_SEG NON_BANKED

static void MCU_init_reset(void);
/*
 ** ===================================================================
 **     Method      :  MCU_init_reset (component MC9S12G128_100)
 **
 **     Description :
 **         Device initialization code for after reset initialization.
 ** ===================================================================
 */
static void MCU_init_reset(void) {

	/*  Initialization of memory configuration */
	/* MMCCTL1: NVMRES=0 */
	MMCCTL1 = 0x00U;
	/* PKGCR: APICLKS7=0,PKGCR2=1,PKGCR1=1,PKGCR0=0 */
	PKGCR = 0x06U;
	/* DIRECT: DP15=0,DP14=0,DP13=0,DP12=0,DP11=0,DP10=0,DP9=0,DP8=0 */
	DIRECT = 0x00U;
	/* IVBR: IVB_ADDR=0xFF */
	IVBR = 0x7FU;
	/* ECLKCTL: NECLK=1,NCLKX2=1,DIV16=0,EDIV4=0,EDIV3=0,EDIV2=0,EDIV1=0,EDIV0=0 */
	ECLKCTL = 0xC0U;
	/* Jump to the default entry point */
	/*lint -save  -e950 Disable MISRA rule (1.1) checking. */
asm jmp _Startup;
/*lint -restore Enable MISRA rule (1.1) checking. */
} /*MCU_init*/

#pragma CODE_SEG DEFAULT
#pragma MESSAGE DISABLE C12056

/*
 ** ===================================================================
 **     Method      :  MCU_init (component MC9S12G128_100)
 **
 **     Description :
 **         Device initialization code for selected peripherals.
 ** ===================================================================
 */
void MCU_init(void) {

/* ### MC9S12G128_100 "Cpu" init code ... */
/*  PE initialization code after reset */
/*  System clock initialization */
IVBR = 0x7FU;
/* CPMUPROT: PROT=0 */
CPMUPROT = 0x26U; /* Disable protection of clock configuration registers */
/* CPMUCLKS: PSTP=0 */
CPMUCLKS &= (unsigned char) ~(unsigned char) 0x40U;
/* CPMUCLKS: PLLSEL=1 */
CPMUCLKS |= (unsigned char) 0x80U; /* Enable the PLL to allow write to divider registers */
/* CPMUREFDIV: REFFRQ1=0,REFFRQ0=1,REFDIV3=0,REFDIV2=0,REFDIV1=0,REFDIV0=1 */
CPMUREFDIV = 0x41U; /* Set the divider register */
/* CPMUSYNR: VCOFRQ1=0,VCOFRQ0=0,SYNDIV5=0,SYNDIV4=0,SYNDIV3=0,SYNDIV2=1,SYNDIV1=0,SYNDIV0=1 */
CPMUSYNR = 0x05U; /* Set the multiplier register */
/* CPMUPOSTDIV: POSTDIV4=0,POSTDIV3=0,POSTDIV2=0,POSTDIV1=0,POSTDIV0=0 */
CPMUPOSTDIV = 0x00U; /* Set the post divider register */
/* CPMUOSC: OSCE=1,OSCBW=0,OSCPINS_EN=0,OSCFILT=0 */
CPMUOSC = 0x80U; /* Enable the oscillator */
/* CPMUPLL: FM1=0,FM0=0 */
CPMUPLL = 0x00U; /* Set the PLL frequency modulation */
while (CPMUFLG_UPOSC == 0U) { /* Wait until the oscillator is qualified by the PLL */
}
/* CPMUPROT: PROT=0 */
CPMUCOP = 0x07;
CPMUPROT = 0x00U; /* Enable protection of clock configuration registers */
/* CPMUCOP: RSBCK=0,WRTMASK=0 */
//CPMUCOP &= (unsigned char)~(unsigned char)0x60U;
/* Common initialization of the CPU registers */
/* WOMM: WOMM1=0 */
WOMM &= (unsigned char) ~(unsigned char) 0x02U;
/* CPMUINT: LOCKIE=0,OSCIE=0 */
CPMUINT &= (unsigned char) ~(unsigned char) 0x12U;
/* CPMULVCTL: LVIE=0 */
CPMULVCTL &= (unsigned char) ~(unsigned char) 0x02U;
/* IRQCR: IRQEN=0 */
IRQCR &= (unsigned char) ~(unsigned char) 0x40U;
/* ATDDIEN: IEN10=1,IEN9=1,IEN8=1,IEN7=1,IEN3=1,IEN2=1,IEN0=1 */
ATDDIEN |= 0xF78DU;
/* ### Init_GPIO init code */
/* Disable interrupts */
/* PIE1AD: PIE1AD7=0,PIE1AD6=0,PIE1AD5=0,PIE1AD4=0,PIE1AD3=0,PIE1AD2=0,PIE1AD1=0,PIE1AD0=0 */
PIE1AD = 0x00U;
/* Clear interrupt flags */
/* PIF1AD: PIF1AD7=1,PIF1AD6=1,PIF1AD5=1,PIF1AD4=1,PIF1AD3=1,PIF1AD2=1,PIF1AD1=1,PIF1AD0=1 */
PIF1AD = 0xFFU;
/* PPS1AD: PPS1AD7=0,PPS1AD2=0,PPS1AD0=0 */
PPS1AD &= (unsigned char) ~(unsigned char) 0x85U;
/* PER1AD: PER1AD7=1,PER1AD3=0,PER1AD2=1,PER1AD0=1 */
PER1AD = (PER1AD & (unsigned char) ~(unsigned char) 0x08U)
		| (unsigned char) 0x85U;
/* DDR1AD: DDR1AD7=1,DDR1AD3=0,DDR1AD2=1,DDR1AD0=1 */
DDR1AD = (DDR1AD & (unsigned char) ~(unsigned char) 0x08U)
		| (unsigned char) 0x85U;
DDR01AD_DDR0AD0 = 1;
DDR01AD_DDR0AD1 = 1;
DDR01AD_DDR0AD2 = 0;
DDR01AD_DDR1AD0 = 1;
DDR01AD_DDR1AD2 = 1;
DDR01AD_DDR1AD3 = 0;

/* ### Init_GPIO init code */
/* Disable interrupts */
/* PIE0AD: PIE0AD7=0,PIE0AD6=0,PIE0AD5=0,PIE0AD4=0,PIE0AD3=0,PIE0AD2=0,PIE0AD1=0,PIE0AD0=0 */
PIE0AD = 0x00U;
/* Clear interrupt flags */
/* PIF0AD: PIF0AD7=1,PIF0AD6=1,PIF0AD5=1,PIF0AD4=1,PIF0AD3=1,PIF0AD2=1,PIF0AD1=1,PIF0AD0=1 */
PIF0AD = 0xFFU;
/* PPS0AD: PPS0AD7=0,PPS0AD6=0,PPS0AD5=0,PPS0AD4=0,PPS0AD1=0,PPS0AD0=0 */
PPS0AD &= (unsigned char) ~(unsigned char) 0xF3U;
/* PER0AD: PER0AD7=1,PER0AD6=1,PER0AD5=1,PER0AD4=1,PER0AD2=0,PER0AD1=1,PER0AD0=1 */
PER0AD = (PER0AD & (unsigned char) ~(unsigned char) 0x04U)
		| (unsigned char) 0xF3U;
/* DDR0AD: DDR0AD7=1,DDR0AD6=1,DDR0AD5=1,DDR0AD4=1,DDR0AD2=0,DDR0AD1=1,DDR0AD0=1 */
DDR0AD = (DDR0AD & (unsigned char) ~(unsigned char) 0x04U)
		| (unsigned char) 0xF3U;
/* ### Init_GPIO init code */
/* Disable interrupts */
/* PIEP: PIEP7=0,PIEP6=0,PIEP5=0,PIEP4=0,PIEP3=0,PIEP2=0,PIEP1=0,PIEP0=0 */
PIEP = 0x00U;
/* Clear interrupt flags */
/* PIFP: PIFP7=1,PIFP6=1,PIFP5=1,PIFP4=1,PIFP3=1,PIFP2=1,PIFP1=1,PIFP0=1 */
PIFP = 0xFFU;
/* PPSP: PPSP6=0,PPSP5=0,PPSP3=0,PPSP1=0 */
PPSP &= (unsigned char) ~(unsigned char) 0x6AU;
/* PERP: PERP6=1,PERP5=1,PERP3=1,PERP1=1 */
PERP |= (unsigned char) 0x6AU;
/* DDRP: DDRP7=1,DDRP6=1,DDRP5=1,DDRP3=1,DDRP1=1 */
DDRP |= (unsigned char) 0xEAU;
/* ### Init_GPIO init code */
/* PPSS: PPSS3=0,PPSS2=0,PPSS1=0,PPSS0=0 */
PPSS &= (unsigned char) ~(unsigned char) 0x0FU;
/* WOMS: WOMS6=0,WOMS5=0,WOMS4=0,WOMS3=0,WOMS2=0,WOMS1=0,WOMS0=0 */
WOMS &= (unsigned char) ~(unsigned char) 0x7FU;
/* PERS: PERS3=1,PERS2=1,PERS1=1,PERS0=1 */
PERS |= (unsigned char) 0x0FU;
/* DDRS: DDRS6=1,DDRS5=1,DDRS4=1,DDRS3=1,DDRS2=1,DDRS1=1,DDRS0=1 */
DDRS |= (unsigned char) 0x7FU;
DDRS_DDRS7 = 0;
PERS_PERS7 = 0;


/* ### Init_GPIO init code */
/* PPST: PPST3=0,PPST2=0,PPST1=0,PPST0=0 */
PPST &= (unsigned char) ~(unsigned char) 0x0FU;
/* PERT: PERT7=0,PERT6=0,PERT3=1,PERT2=1,PERT1=1,PERT0=1 */
PERT = (PERT & (unsigned char) ~(unsigned char) 0xC0U) | (unsigned char) 0x0FU;
/* DDRT: DDRT7=0,DDRT6=0,DDRT5=1,DDRT4=1,DDRT3=1,DDRT2=1,DDRT1=0,DDRT0=0 */
DDRT = 0x3CU;
/* ### Init_GPIO init code */
/* PUCR: PUPAE=1 */
PUCR |= (unsigned char) 0x01U;
/* DDRA: DDRA7=1,DDRA6=1,DDRA5=1,DDRA0=1 */
DDRA |= (unsigned char) 0xE7U;
/* ### Init_GPIO init code */
/* PORTB: PB1=1 */
PORTB |= (unsigned char) 0x02U;
/* PUCR: PUPBE=1 */
PUCR |= (unsigned char) 0x02U;
/* DDRB: DDRB6=0,DDRB5=1,DDRB4=1,DDRB3=1,DDRB2=0,DDRB1=1,DDRB0=1 */
DDRB = (DDRB & (unsigned char) ~(unsigned char) 0x44U) | (unsigned char) 0x3BU;

/* ### Init_MSCAN init code */
/* CANCTL0: INITRQ=1 */
CANCTL0 |= (unsigned char) 0x01U;
while (CANCTL1_INITAK == 0U) { /* Wait for init acknowledge */
}
/* CANCTL1: CANE=1,CLKSRC=1,LOOPB=0,LISTEN=1,BORM=0,WUPM=0,SLPAK=0,INITAK=1 */
CANCTL1 = 0xD1U;
/* CANBTR1: SAMP=0,TSEG22=0,TSEG21=0,TSEG20=1,TSEG13=0,TSEG12=0,TSEG11=1,TSEG10=0 */
CANBTR1 = 0x12U;
/* CANBTR0: SJW1=1,SJW0=1,BRP5=0,BRP4=0,BRP3=1,BRP2=1,BRP1=1,BRP0=1 */
CANBTR0 = 0xCFU;
/* CANIDAC: IDAM1=0,IDAM0=0,IDHIT2=0,IDHIT1=0,IDHIT0=0 */
CANIDAC = 0x00U;
/* CANIDAR0: AC7=1,AC6=1,AC5=1,AC4=1,AC3=1,AC2=1,AC1=1,AC0=1 */
CANIDAR0 = 0xFFU;
/* CANIDAR1: AC7=1,AC6=1,AC5=1,AC4=1,AC3=1,AC2=1,AC1=1,AC0=1 */
CANIDAR1 = 0xFFU;
/* CANIDAR2: AC7=1,AC6=1,AC5=1,AC4=1,AC3=1,AC2=1,AC1=1,AC0=1 */
CANIDAR2 = 0xFFU;
/* CANIDAR3: AC7=1,AC6=1,AC5=1,AC4=1,AC3=1,AC2=1,AC1=1,AC0=1 */
CANIDAR3 = 0xFFU;
/* CANIDAR4: AC7=1,AC6=1,AC5=1,AC4=1,AC3=1,AC2=1,AC1=1,AC0=1 */
CANIDAR4 = 0xFFU;
/* CANIDAR5: AC7=1,AC6=1,AC5=1,AC4=1,AC3=1,AC2=1,AC1=1,AC0=1 */
CANIDAR5 = 0xFFU;
/* CANIDAR6: AC7=1,AC6=1,AC5=1,AC4=1,AC3=1,AC2=1,AC1=1,AC0=1 */
CANIDAR6 = 0xFFU;
/* CANIDAR7: AC7=1,AC6=1,AC5=1,AC4=1,AC3=1,AC2=1,AC1=1,AC0=1 */
CANIDAR7 = 0xFFU;
/* CANIDMR0: AM7=0,AM6=0,AM5=0,AM4=0,AM3=0,AM2=0,AM1=0,AM0=0 */
CANIDMR0 = 0x00U;
/* CANIDMR1: AM7=0,AM6=0,AM5=0,AM4=0,AM3=0,AM2=0,AM1=0,AM0=0 */
CANIDMR1 = 0x00U;
/* CANIDMR2: AM7=0,AM6=0,AM5=0,AM4=0,AM3=0,AM2=0,AM1=0,AM0=0 */
CANIDMR2 = 0x00U;
/* CANIDMR3: AM7=0,AM6=0,AM5=0,AM4=0,AM3=0,AM2=0,AM1=0,AM0=0 */
CANIDMR3 = 0x00U;
/* CANIDMR4: AM7=0,AM6=0,AM5=0,AM4=0,AM3=0,AM2=0,AM1=0,AM0=0 */
CANIDMR4 = 0x00U;
/* CANIDMR5: AM7=0,AM6=0,AM5=0,AM4=0,AM3=0,AM2=0,AM1=0,AM0=0 */
CANIDMR5 = 0x00U;
/* CANIDMR6: AM7=0,AM6=0,AM5=0,AM4=0,AM3=0,AM2=0,AM1=0,AM0=0 */
CANIDMR6 = 0x00U;
/* CANIDMR7: AM7=0,AM6=0,AM5=0,AM4=0,AM3=0,AM2=0,AM1=0,AM0=0 */
CANIDMR7 = 0x00U;
/* CANCTL0: INITRQ=0 */
CANCTL0 &= (unsigned char) ~(unsigned char) 0x01U;
while (CANCTL1_INITAK) { /* Wait for init exit */
}
/* CANCTL0: RXFRM=0,RXACT=0,CSWAI=0,SYNCH=0,TIME=0,WUPE=0,SLPRQ=0,INITRQ=0 */
CANCTL0 = 0x00U;
/* CANRIER: WUPIE=0,CSCIE=0,RSTATE1=0,RSTATE0=0,TSTATE1=0,TSTATE0=0,OVRIE=0,RXFIE=1 */
CANRIER = 0x01U;
/* CANTIER: TXEIE2=0,TXEIE1=0,TXEIE0=0 */
CANTIER = 0x00U;
/* ### Init_GPIO init code */
/* PUCR: PUPCE=1 */
PUCR |= (unsigned char) 0x04U;
/* DDRC: DDRC7=1,DDRC6=1,DDRC5=1,DDRC4=1,DDRC3=1,DDRC2=1,DDRC1=1,DDRC0=1 */
DDRC = 0xFFU;
/* ### Init_GPIO init code */
/* PUCR: PUPDE=1 */
PUCR |= (unsigned char) 0x08U;
/* DDRD: DDRD7=1,DDRD6=1,DDRD5=1,DDRD4=1,DDRD3=1,DDRD2=1,DDRD1=1,DDRD0=1 */
DDRD = 0xFFU;
/* ### Init_GPIO init code */
/* Disable interrupts */
/* PIEJ: PIEJ7=0,PIEJ6=0,PIEJ5=0,PIEJ4=0,PIEJ3=0,PIEJ2=0,PIEJ1=0,PIEJ0=0 */
PIEJ = 0x00U;
/* Clear interrupt flags */
/* PIFJ: PIFJ7=1,PIFJ6=1,PIFJ5=1,PIFJ4=1,PIFJ3=1,PIFJ2=1,PIFJ1=1,PIFJ0=1 */
PIFJ = 0xFFU;
/* PPSJ: PPSJ7=0,PPSJ6=0,PPSJ4=0,PPSJ3=0,PPSJ2=0,PPSJ1=0,PPSJ0=0 */
PPSJ &= (unsigned char) ~(unsigned char) 0xDFU;
/* PERJ: PERJ7=1,PERJ6=1,PERJ4=1,PERJ3=1,PERJ2=1,PERJ1=1,PERJ0=1 */
PERJ |= (unsigned char) 0xDFU;
/* DDRJ: DDRJ7=1,DDRJ6=1,DDRJ4=0,DDRJ3=1,DDRJ2=1,DDRJ1=1,DDRJ0=0 */
DDRJ = (DDRJ & (unsigned char) ~(unsigned char) 0x11U) | (unsigned char) 0xCEU;
/* ### Init_API init code */
/* CPMUAPICTL: APICLK=0,APIES=0,APIEA=0,APIFE=0,APIE=0,APIF=0 */
CPMUAPICTL = 0x00U;
/* CPMUAPIR: APIR15=1,APIR14=1,APIR13=1,APIR12=0,APIR11=1,APIR10=0,APIR9=1,APIR8=0,APIR7=0,APIR6=1,APIR5=1,APIR4=0,APIR3=0,APIR2=0,APIR1=0,APIR0=0 */
CPMUAPIR = 1199; //Period = 2*(APIR[15:0] + 1) * Bus Clock period =  0.1ms
/* CPMUACLKTR: ACLKTR5=0,ACLKTR4=0,ACLKTR3=0,ACLKTR2=0,ACLKTR1=0,ACLKTR0=0 */
CPMUACLKTR = 0x00U;
/* CPMUAPICTL: APICLK=1,APIE=1,APIF=1 */
CPMUAPICTL |= (unsigned char) 0x83U;
/* CPMUAPICTL: APIFE=1 */
CPMUAPICTL |= (unsigned char) 0x04U;
/* ### Init_TIM init code */
/* TSCR1: TEN=0 */
TSCR1 &= (unsigned char) ~(unsigned char) 0x80U;
/* TIE: C7I=0,C6I=0,C5I=0,C4I=0,C3I=0,C2I=0,C1I=0,C0I=0 */
TIE = 0x00U;
/* PACTL: PAEN=0,PAI=0 */
PACTL &= (unsigned char) ~(unsigned char) 0x41U;
/* TIOS: IOS7=0,IOS6=0,IOS5=0,IOS4=0,IOS3=0,IOS2=1,IOS1=1,IOS0=1 */
TIOS = 0x07U;
/* TC0: BIT15=0,BIT14=0,BIT13=0,BIT12=0,BIT11=0,BIT10=0,BIT9=1,BIT8=0,BIT7=0,BIT6=1,BIT5=0,BIT4=0,BIT3=1,BIT2=1,BIT1=0,BIT0=0 */
TC0 = 0x024CU;
/* TC2: BIT15=0,BIT14=0,BIT13=0,BIT12=0,BIT11=0,BIT10=0,BIT9=1,BIT8=0,BIT7=0,BIT6=1,BIT5=0,BIT4=0,BIT3=1,BIT2=1,BIT1=0,BIT0=0 */
TC2 = 0x024CU;
/* TC1: BIT15=0,BIT14=0,BIT13=0,BIT12=0,BIT11=0,BIT10=0,BIT9=0,BIT8=0,BIT7=0,BIT6=0,BIT5=0,BIT4=0,BIT3=0,BIT2=0,BIT1=0,BIT0=1 */
TC1 = 0x01U;
/* OCPD: OCPD7=0,OCPD6=0,OCPD5=0,OCPD4=0,OCPD3=0,OCPD2=1,OCPD1=1,OCPD0=1 */
OCPD = 0x07U;
/* OC7M: OC7M7=0,OC7M6=0,OC7M5=0,OC7M4=0,OC7M3=0,OC7M2=0,OC7M1=0,OC7M0=0 */
OC7M = 0x00U;
/* OC7D: OC7D7=0,OC7D6=0,OC7D5=0,OC7D4=0,OC7D3=0,OC7D2=0,OC7D1=1,OC7D0=0 */
OC7D = 0x02U;
/* TTOV: TOV7=0,TOV6=0,TOV5=0,TOV4=0,TOV3=0,TOV2=0,TOV1=0,TOV0=0 */
TTOV = 0x00U;
/* TCTL1: OM7=0,OL7=0,OM6=0,OL6=0,OM5=0,OL5=0,OM4=0,OL4=0 */
TCTL1 = 0x00U;
/* TCTL2: OM3=0,OL3=0,OM2=0,OL2=0,OM1=0,OL1=0,OM0=0,OL0=0 */
TCTL2 = 0x00U;
/* TCTL3: EDG7B=0,EDG7A=0,EDG6B=0,EDG6A=0,EDG5B=0,EDG5A=0,EDG4B=0,EDG4A=0 */
TCTL3 = 0x00U;
/* TCTL4: EDG3B=0,EDG3A=0,EDG2B=0,EDG2A=0,EDG1B=0,EDG1A=0,EDG0B=0,EDG0A=0 */
TCTL4 = 0x00U;
/* TFLG1: C7F=1,C6F=1,C5F=1,C4F=1,C3F=1,C2F=1,C1F=1,C0F=1 */
TFLG1 = 0xFFU;
/* TFLG2: TOF=1 */
TFLG2 = 0x80U;
/* TIE: C7I=0,C6I=0,C5I=0,C4I=0,C3I=0,C2I=1,C1I=0,C0I=1 */

TIE = 0; //!<取消所有定时器
/* TSCR2: TOI=0,TCRE=1,PR2=0,PR1=1,PR0=1 */
TSCR2 = 0x0BU;
/* PACNT: BIT15=0,BIT14=0,BIT13=0,BIT12=0,BIT11=0,BIT10=0,BIT9=0,BIT8=0,BIT7=0,BIT6=0,BIT5=0,BIT4=0,BIT3=0,BIT2=0,BIT1=0,BIT0=0 */
PACNT = 0x00U;
/* PTPSR: PTPS7=0,PTPS6=0,PTPS5=0,PTPS4=0,PTPS3=0,PTPS2=0,PTPS1=0,PTPS0=0 */
PTPSR = 0x00U;
/* TSCR1: TEN=1,TSWAI=0,TSFRZ=0,TFFCA=0,PRNT=0 */
TSCR1 = 0x80U;
/* PAFLG: PAOVF=1,PAIF=1 */
PAFLG = 0x03U;
/* PACTL: PAEN=0,PAMOD=0,PEDGE=0,CLK1=0,CLK0=0,PAOVI=0,PAI=0 */
PACTL = 0x00U;
DDRM_DDRM3 = 0;
DDRP_DDRP4 = 1;
DDRP_DDRP2 = 1;
DDRP_DDRP0 = 1;
DDRT_DDRT3 = 1;
DDRM_DDRM2 = 1;
DDRB_DDRB7 = 1;
DDRA_DDRA3=  1;
DDRB_DDRB5 = 1;

DDRP_DDRP6 = 0;
/* ### */
/* Initial interrupt priority */
/*lint -save  -e950 Disable MISRA rule (1.1) checking. */
//asm CLI;                             /* Enable interrupts */
/*lint -restore Enable MISRA rule (1.1) checking. */
} /*MCU_init*/

#pragma MESSAGE DEFAULT C12056

/*lint -save  -e765 Disable MISRA rule (8.10) checking. */
#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
 ** ===================================================================
 **     Interrupt handler : isr_default
 **
 **     Description :
 **         User interrupt service routine.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
__interrupt void isr_default(void) {
/* Write your interrupt code here ... */

}
/* end of isr_default */
#pragma CODE_SEG DEFAULT

#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
 ** ===================================================================
 **     Interrupt handler : isrVportad
 **
 **     Description :
 **         User interrupt service routine.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
__interrupt void isrVportad(void) {
/* Write your interrupt code here ... */

}
/* end of isrVportad */
#pragma CODE_SEG DEFAULT
/**
  * @brief   mileage_handler
  *          里程运算
  * @param   none
  * @retval  none
  */
void mileage_handler(void)
{
	static U16 TimerCounter = 0;
	TimerCounter++;
	if (TimerCounter>=500)
	{
		TimerCounter = 0;
		// s = v * 1000 /3600 * t m; ==> v * 10/ 72 m
		// ==> KmTotal_T1 0.1m/bit
		KmTotal_T1=KmTotal_T1+ ((unsigned long)VehicleSpeed*100 + 36)/72;//四舍五入 这里车速提高10%不在计算时进行计算,主要为了不对数据进行拓展(32位为非原子级操作)
		if(KmTotal_T1>1000)
		{
			U16 temp;
			temp = KmTotal_T1 % 1000;
			KmTotal_T1 = KmTotal_T1/1000;
			KmTotalShort=KmTotalShort+KmTotal_T1;
			KmTotalLong =KmTotalLong+KmTotal_T1;
			KmTotal_T1= temp;         
			if(KmTotalLong>=(KmTotalLong2+1000))
			{
				KmTotalLong2=KmTotalLong;
			}               
		}
	}
}

void pulse_output(void)
{
	static PulseWidth temp = {0};
	static unsigned int cont = 0;
	cont++;
	if (cont<temp.time_off)
	{
		if (cont<temp.time_on)
		{
			PORTB_PB5 = 1;
		}
		else
		{
			PORTB_PB5 = 0;
		}
	}
	else
	{
		PORTB_PB5 = 0;
		cont = 0;
		temp.time_on = g_pulse.time_on;
		temp.time_off = g_pulse.time_off;
	}
}

void buzzer_AutoOutput(void)
{
	static BEEP_INFO temp = {0};
	static unsigned int cont = 0;
	cont++;
	if (start_lock == 1)
	{
		return;
	}
	if (alarm_msg == 1)
	{
			beep_info.cont = 0;
			beep_info.temp = 0;
			if(can_signal.ID_1810A6A0.LED.bit.LED7)
			{
				BEEP = 1;
			}
			else
			{
				BEEP = 0;
			}			
	}
	else if (temp.cont != 0)
	{
		if (cont<temp.time_off)
		{
			if (cont<temp.time_on)
			{
				BEEP = 1;
			}
			else
			{
				BEEP = 0;
			}
		}
		else
		{
			temp.cont--;
			cont = 0;
			BEEP = 0;
			if (temp.temp<beep_info.temp)
			{
				//优先级较高任务
				memcpy(&temp,&beep_info,sizeof(beep_info));
				beep_info.temp = 0;
			}
		}
	}
	else
	{
		cont = 0;
		BEEP = 0;
		if (beep_info.temp != 0)
		{
			memcpy(&temp,&beep_info,sizeof(beep_info));
			beep_info.temp = 0;
		}
	}
}

#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
 ** ===================================================================
 **     Interrupt handler : isrVapi
 **
 **     Description :
 **         User interrupt service routine.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
__interrupt void isrVapi(void) {
	static U8  class1 = 0;

	/* Write your interrupt code here ... */
	CPMUAPICTL_APIF = 1;
	
	/* Write your interrupt code here ... */
	CPMUAPICTL_APIF = 1;
	class1++;
	if (class1>=10)
	{
		class1 = 0;
	}
	switch(class1)
	{
		case 0: MsConfig = 1;Runtime++;break;
		case 1: smUpdates();break;
		case 2: smProcess();break;
		case 3: mileage_handler();break;
		case 4: pulse_output();break;
		case 5: buzzer_AutoOutput();break;
		case 6: SetPanelStatus(); break;
		case 7: break;
		case 8:break;
		default:break;
		
	}
	
}
/* end of isrVapi */
#pragma CODE_SEG DEFAULT

#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
 ** ===================================================================
 **     Interrupt handler : isrVportp
 **
 **     Description :
 **         User interrupt service routine.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
__interrupt void isrVportp(void) {
/* Write your interrupt code here ... */

}
/* end of isrVportp */
#pragma CODE_SEG DEFAULT

#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
 ** ===================================================================
 **     Interrupt handler : isrVcantx
 **
 **     Description :
 **         User interrupt service routine.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
__interrupt void isrVcantx(void) {
/* Write your interrupt code here ... */

}
/* end of isrVcantx */
#pragma CODE_SEG DEFAULT

#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
 ** ===================================================================
 **     Interrupt handler : isrVcanrx
 **
 **     Description :
 **         User interrupt service routine.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
__interrupt void isrVcanrx(void) {
/* Write your interrupt code here ... */
unsigned char length, index;
unsigned char temp[8], IDtemp[4], Temp1;
unsigned long ID;
unsigned int u16Temp1;

//LIGHT_Dryer = 0;

length = (CANRXDLR & 0x0F);
for (index = 0; index < length; index++)
	temp[index] = *(&CANRXDSR0 + index); /* Get received data */

IDtemp[0] = CANRXIDR0;
IDtemp[1] = CANRXIDR1;
IDtemp[2] = CANRXIDR2;
IDtemp[3] = CANRXIDR3;

ID = (((unsigned long) IDtemp[2]) << 7) | (((unsigned long) IDtemp[3]) >> 1);
ID = ID | (((unsigned long) (IDtemp[1] & 0x07)) << 15);
ID = ID | (((unsigned long) ((IDtemp[1] & 0xE0) >> 5)) << 18);
ID = ID | (((unsigned long) (IDtemp[0])) << 21);

rxdata[0] = temp[0];/* Get received data */
rxdata[1] = temp[1];
rxdata[2] = temp[2];
rxdata[3] = temp[3];
rxdata[4] = temp[4];
rxdata[5] = temp[5];
rxdata[6] = temp[6];
rxdata[7] = temp[7];

CANRFLG = 0x01; /* Clear RXF */

CanReceivedMsgHandle(ID,rxdata);
//CAN0SendFrame(0x0C03A1A7, 0x03, 8, "12345678");
}
/* end of isrVcanrx */
#pragma CODE_SEG DEFAULT

#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
 ** ===================================================================
 **     Interrupt handler : isrVcanerr
 **
 **     Description :
 **         User interrupt service routine.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
__interrupt void isrVcanerr(void) {
/* Write your interrupt code here ... */

}
/* end of isrVcanerr */
#pragma CODE_SEG DEFAULT

#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
 ** ===================================================================
 **     Interrupt handler : isrVcanwkup
 **
 **     Description :
 **         User interrupt service routine.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
__interrupt void isrVcanwkup(void) {
/* Write your interrupt code here ... */

}
/* end of isrVcanwkup */
#pragma CODE_SEG DEFAULT

#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
 ** ===================================================================
 **     Interrupt handler : isrVportj
 **
 **     Description :
 **         User interrupt service routine.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
__interrupt void isrVportj(void) {
/* Write your interrupt code here ... */

}
/* end of isrVportj */
#pragma CODE_SEG DEFAULT

#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
 ** ===================================================================
 **     Interrupt handler : isrVtimpaie
 **
 **     Description :
 **         User interrupt service routine.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
__interrupt void isrVtimpaie(void) {
/* Write your interrupt code here ... */

}
/* end of isrVtimpaie */
#pragma CODE_SEG DEFAULT

#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
 ** ===================================================================
 **     Interrupt handler : isrVtimpaaovf
 **
 **     Description :
 **         User interrupt service routine.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
__interrupt void isrVtimpaaovf(void) {
/* Write your interrupt code here ... */

}
/* end of isrVtimpaaovf */
#pragma CODE_SEG DEFAULT

#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
 ** ===================================================================
 **     Interrupt handler : isrVtimovf
 **
 **     Description :
 **         User interrupt service routine.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
__interrupt void isrVtimovf(void) {
/* Write your interrupt code here ... */
TFLG2_TOF = 1;

}
/* end of isrVtimovf */
#pragma CODE_SEG DEFAULT

#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
 ** ===================================================================
 **     Interrupt handler : isrVtimch2
 **
 **     Description :
 **         User interrupt service routine.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
__interrupt void isrVtimch2(void) {
/* Write your interrupt code here ... */
//mch2_process();
uint16_t buf;

buf = TCNT;
TC2 = buf + 3000;       //设置定时时间为1ms
MsConfig = 1;
Runtime++;
smUpdates();
SetPanelStatus();
TFLG1_C2F = 1;
}
/* end of isrVtimch2 */
#pragma CODE_SEG DEFAULT

#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
 ** ===================================================================
 **     Interrupt handler : isrVtimch1
 **
 **     Description :
 **         User interrupt service routine.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
__interrupt void isrVtimch1(void) {
/* Write your interrupt code here ... */
//mch1_process();
TFLG1_C1F = 1;

}
/* end of isrVtimch1 */
#pragma CODE_SEG DEFAULT

#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
 ** ===================================================================
 **     Interrupt handler : isrVtimch0
 **
 **     Description :
 **         User interrupt service routine.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
__interrupt void isrVtimch0(void) {
	/* Write your interrupt code here ... */
	TFLG1_C0F = 1;

}
/* end of isrVtimch0 */
#pragma CODE_SEG DEFAULT

/*lint -restore Enable MISRA rule (8.10) checking. */

/*lint -save  -e950 Disable MISRA rule (1.1) checking. */
/* Initialization of the CPU registers in FLASH */
/*lint -restore Enable MISRA rule (1.1) checking. */

/* Interrupt vector table */

/* ISR prototype */
typedef void (*near tIsrFunc)(void);

#ifndef UNASSIGNED_ISR
#define UNASSIGNED_ISR isr_default   /* unassigned interrupt service routine */
#endif
/*lint -save  -e950 Disable MISRA rule (1.1) checking. */


static const tIsrFunc _InterruptVectorTable[] @0x7F80U = { /* Interrupt vector table */
/*lint -restore Enable MISRA rule (1.1) checking. */
/* ISR name                               No.  Address  Name          Description */
&UNASSIGNED_ISR, /* 0x40  0xFF80   ivVsi         unused by PE */
&isrVportad, /* 0x41  0xFF82   ivVportad     used by PE */
&UNASSIGNED_ISR, /* 0x42  0xFF84   ivVatdcompare unused by PE */
&UNASSIGNED_ISR, /* 0x43  0xFF86   ivVReserved60 unused by PE */
&isrVapi, /* 0x44  0xFF88   ivVapi        used by PE */
&UNASSIGNED_ISR, /* 0x45  0xFF8A   ivVlvi        unused by PE */
&UNASSIGNED_ISR, /* 0x46  0xFF8C   ivVReserved57 unused by PE */
&isrVportp, /* 0x47  0xFF8E   ivVportp      used by PE */
&UNASSIGNED_ISR, /* 0x48  0xFF90   ivVReserved55 unused by PE */
&UNASSIGNED_ISR, /* 0x49  0xFF92   ivVReserved54 unused by PE */
&UNASSIGNED_ISR, /* 0x4A  0xFF94   ivVReserved53 unused by PE */
&UNASSIGNED_ISR, /* 0x4B  0xFF96   ivVReserved52 unused by PE */
&UNASSIGNED_ISR, /* 0x4C  0xFF98   ivVReserved51 unused by PE */
&UNASSIGNED_ISR, /* 0x4D  0xFF9A   ivVReserved50 unused by PE */
&UNASSIGNED_ISR, /* 0x4E  0xFF9C   ivVReserved49 unused by PE */
&UNASSIGNED_ISR, /* 0x4F  0xFF9E   ivVReserved48 unused by PE */
&UNASSIGNED_ISR, /* 0x50  0xFFA0   ivVReserved47 unused by PE */
&UNASSIGNED_ISR, /* 0x51  0xFFA2   ivVReserved46 unused by PE */
&UNASSIGNED_ISR, /* 0x52  0xFFA4   ivVReserved45 unused by PE */
&UNASSIGNED_ISR, /* 0x53  0xFFA6   ivVReserved44 unused by PE */
&UNASSIGNED_ISR, /* 0x54  0xFFA8   ivVReserved43 unused by PE */
&UNASSIGNED_ISR, /* 0x55  0xFFAA   ivVReserved42 unused by PE */
&UNASSIGNED_ISR, /* 0x56  0xFFAC   ivVReserved41 unused by PE */
&UNASSIGNED_ISR, /* 0x57  0xFFAE   ivVReserved40 unused by PE */
&isrVcantx, /* 0x58  0xFFB0   ivVcantx      used by PE */
&isrVcanrx, /* 0x59  0xFFB2   ivVcanrx      used by PE */
&isrVcanerr, /* 0x5A  0xFFB4   ivVcanerr     used by PE */
&isrVcanwkup, /* 0x5B  0xFFB6   ivVcanwkup    used by PE */
&UNASSIGNED_ISR, /* 0x5C  0xFFB8   ivVflash      unused by PE */
&UNASSIGNED_ISR, /* 0x5D  0xFFBA   ivVflashfd    unused by PE */
&UNASSIGNED_ISR, /* 0x5E  0xFFBC   ivVspi2       unused by PE */
&UNASSIGNED_ISR, /* 0x5F  0xFFBE   ivVspi1       unused by PE */
&UNASSIGNED_ISR, /* 0x60  0xFFC0   ivVReserved31 unused by PE */
&UNASSIGNED_ISR, /* 0x61  0xFFC2   ivVsci2       unused by PE */
&UNASSIGNED_ISR, /* 0x62  0xFFC4   ivVReserved29 unused by PE */
&UNASSIGNED_ISR, /* 0x63  0xFFC6   ivVcpmuplllck unused by PE */
&UNASSIGNED_ISR, /* 0x64  0xFFC8   ivVcpmuocsns  unused by PE */
&UNASSIGNED_ISR, /* 0x65  0xFFCA   ivVReserved26 unused by PE */
&UNASSIGNED_ISR, /* 0x66  0xFFCC   ivVReserved25 unused by PE */
&isrVportj, /* 0x67  0xFFCE   ivVportj      used by PE */
&UNASSIGNED_ISR, /* 0x68  0xFFD0   ivVReserved23 unused by PE */
&UNASSIGNED_ISR, /* 0x69  0xFFD2   ivVatd        unused by PE */
&UNASSIGNED_ISR, /* 0x6A  0xFFD4   ivVsci1       unused by PE */
&UNASSIGNED_ISR, /* 0x6B  0xFFD6   ivVsci0       unused by PE */
&UNASSIGNED_ISR, /* 0x6C  0xFFD8   ivVspi0       unused by PE */
&isrVtimpaie, /* 0x6D  0xFFDA   ivVtimpaie    used by PE */
&isrVtimpaaovf, /* 0x6E  0xFFDC   ivVtimpaaovf  used by PE */
&isrVtimovf, /* 0x6F  0xFFDE   ivVtimovf     used by PE */
&UNASSIGNED_ISR, /* 0x70  0xFFE0   ivVtimch7     unused by PE */
&UNASSIGNED_ISR, /* 0x71  0xFFE2   ivVtimch6     unused by PE */
&UNASSIGNED_ISR, /* 0x72  0xFFE4   ivVtimch5     unused by PE */
&UNASSIGNED_ISR, /* 0x73  0xFFE6   ivVtimch4     unused by PE */
&UNASSIGNED_ISR, /* 0x74  0xFFE8   ivVtimch3     unused by PE */
&isrVtimch2, /* 0x75  0xFFEA   ivVtimch2     used by PE */
&isrVtimch1, /* 0x76  0xFFEC   ivVtimch1     used by PE */
&isrVtimch0, /* 0x77  0xFFEE   ivVtimch0     used by PE */
&UNASSIGNED_ISR, /* 0x78  0xFFF0   ivVrti        unused by PE */
&UNASSIGNED_ISR, /* 0x79  0xFFF2   ivVirq        unused by PE */
&UNASSIGNED_ISR, /* 0x7A  0xFFF4   ivVxirq       unused by PE */
&UNASSIGNED_ISR, /* 0x7B  0xFFF6   ivVswi        unused by PE */
&UNASSIGNED_ISR, /* 0x7C  0xFFF8   ivVtrap       unused by PE */
&MCU_init_reset, /* 0xFFFA  ivVcop         unused by PE */
&MCU_init_reset, /* 0xFFFC  ivVclkmon      unused by PE */
&MCU_init_reset, /* 0xFFFE  ivVreset       used by PE */
};

#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
 ** ===================================================================
 **     Interrupt handler : isrVatdcompare
 **
 **     Description :
 **         User interrupt service routine.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
__interrupt void isrVatdcompare(void) {
/* Write your interrupt code here ... */

}
/* end of isrVatdcompare */

#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
 ** ===================================================================
 **     Interrupt handler : isrVatd
 **
 **     Description :
 **         User interrupt service routine.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
__interrupt void isrVatd(void) {
/* Write your interrupt code here ... */

}
/* end of isrVatd */

#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
 ** ===================================================================
 **     Interrupt handler : isrVspi1
 **
 **     Description :
 **         User interrupt service routine.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
__interrupt void isrVspi1(void) {
/* Write your interrupt code here ... */

}
/* end of isrVspi1 */

#pragma CODE_SEG __NEAR_SEG NON_BANKED
/*
 ** ===================================================================
 **     Interrupt handler : isrVspi2
 **
 **     Description :
 **         User interrupt service routine.
 **     Parameters  : None
 **     Returns     : Nothing
 ** ===================================================================
 */
__interrupt void isrVspi2(void) {
/* Write your interrupt code here ... */

}
/* end of isrVspi2 */





/* END MCUinit */

/*
 ** ###################################################################
 **
 **     This file was created by Processor Expert 3.02 [04.44]
 **     for the Freescale HCS12 series of microcontrollers.
 **
 ** ###################################################################
 */
